#!/bin/bash
set -euo pipefail

# DeepFilterNet3 — Emscripten WASM build script
# Outputs: dfn3.js + dfn3.wasm (or single-file dfn3-worklet.js for AudioWorklet)

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
cd "$SCRIPT_DIR"

# Check emcc
if ! command -v emcc &>/dev/null; then
    echo "ERROR: emcc not found. Install Emscripten SDK first."
    echo "  git clone https://github.com/emscripten-core/emsdk.git"
    echo "  cd emsdk && ./emsdk install latest && ./emsdk activate latest"
    echo "  source ./emsdk_env.sh"
    exit 1
fi

echo "=== Building DeepFilterNet3 WASM ==="

# Compile
emcc dfn3_wasm.c kiss_fft.c kiss_fftr.c \
    -O3 \
    -msimd128 \
    -s WASM=1 \
    -s MODULARIZE=1 \
    -s EXPORT_NAME="createDFN3Module" \
    -s EXPORTED_FUNCTIONS='["_dfn3_wasm_create","_dfn3_wasm_get_input_ptr","_dfn3_wasm_get_output_ptr","_dfn3_wasm_get_input_size","_dfn3_wasm_get_output_size","_dfn3_wasm_process","_dfn3_wasm_get_lsnr","_dfn3_wasm_set_atten_lim","_dfn3_wasm_set_post_filter_beta","_dfn3_wasm_set_min_db_thresh","_dfn3_wasm_set_max_db_erb_thresh","_dfn3_wasm_set_max_db_df_thresh","_dfn3_wasm_destroy","_malloc","_free"]' \
    -s EXPORTED_RUNTIME_METHODS='["ccall","cwrap","HEAPF32","HEAPU8"]' \
    -s ALLOW_MEMORY_GROWTH=0 \
    -s INITIAL_MEMORY=67108864 \
    -s STACK_SIZE=1048576 \
    -s ENVIRONMENT='web,worker' \
    -s SINGLE_FILE=0 \
    -s FILESYSTEM=0 \
    -s ASSERTIONS=0 \
    -s MALLOC=emmalloc \
    --no-entry \
    -lm \
    -o dfn3.js

echo "Built: dfn3.js + dfn3.wasm"
ls -lh dfn3.js dfn3.wasm

# Generate single-file worklet with embedded WASM + weights
echo ""
echo "=== Generating AudioWorklet (dfn3-worklet.js) ==="

WASM_B64=$(base64 < dfn3.wasm | tr -d '\n')
WEIGHTS_B64=$(base64 < dfn3_weights.bin | tr -d '\n')

WORKLET_OUT="../static/js/webclient/denoiser/dfn3-worklet.js"
mkdir -p "$(dirname "$WORKLET_OUT")"

# Patch Emscripten glue JS for AudioWorkletGlobalScope compatibility
# Replace self.location.href with a safe fallback (AudioWorklet has no self.location)
sed -i '' 's/self\.location\.href/(typeof self!=="undefined"\&\&self.location?self.location.href:"")/g' dfn3.js
GLUE_JS=$(cat dfn3.js)

cat > "$WORKLET_OUT" << 'WORKLET_HEADER'
/* DeepFilterNet3 AudioWorklet — auto-generated by build.sh, DO NOT EDIT */
/* eslint-disable */

// Polyfills for AudioWorkletGlobalScope
// Emscripten ENVIRONMENT='worker' references self.location.href which doesn't
// exist in AudioWorkletGlobalScope — provide a stub so initialization succeeds.
if (typeof self !== 'undefined' && typeof self.location === 'undefined') {
    self.location = { href: '' };
}
if (typeof globalThis.atob === 'undefined') {
    globalThis.atob = function(b64) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        let result = '';
        b64 = b64.replace(/[^A-Za-z0-9+/=]/g, '');
        for (let i = 0; i < b64.length; i += 4) {
            const a = chars.indexOf(b64[i]);
            const b = chars.indexOf(b64[i + 1]);
            const c = chars.indexOf(b64[i + 2]);
            const d = chars.indexOf(b64[i + 3]);
            result += String.fromCharCode((a << 2) | (b >> 4));
            if (c !== 64) result += String.fromCharCode(((b & 15) << 4) | (c >> 2));
            if (d !== 64) result += String.fromCharCode(((c & 3) << 6) | d);
        }
        return result;
    };
}
if (typeof globalThis.performance === 'undefined') {
    globalThis.performance = { now: () => Date.now() };
}

WORKLET_HEADER

echo "" >> "$WORKLET_OUT"
echo "// --- Emscripten module ---" >> "$WORKLET_OUT"
echo "$GLUE_JS" >> "$WORKLET_OUT"

cat >> "$WORKLET_OUT" << WORKLET_DATA

// --- Embedded data (base64) ---
const DFN3_WASM_B64 = "${WASM_B64}";
const DFN3_WEIGHTS_B64 = "${WEIGHTS_B64}";

WORKLET_DATA

cat >> "$WORKLET_OUT" << 'WORKLET_PROCESSOR'

function b64ToUint8(b64) {
    const raw = atob(b64);
    const arr = new Uint8Array(raw.length);
    for (let i = 0; i < raw.length; i++) arr[i] = raw.charCodeAt(i);
    return arr;
}

const DFN3_HOP = 480;       // 48 kHz input/output hop
const INT16_SCALE = 32767;

class DFN3Worklet extends AudioWorkletProcessor {
    constructor(options) {
        super();
        this.ready = false;
        this.proc = null;
        this.inputPtr = null;
        this.outputPtr = null;
        this.accumBuf = new Float32Array(DFN3_HOP);
        this.accumPos = 0;

        const opts = options.processorOptions || {};
        const inRate = opts.inputSampleRate || 48000;
        const outRate = opts.outputSampleRate || 16000;
        this.bufSize = opts.bufferSize || 3200;
        this.ratio = inRate / outRate;  // 3.0 for 48k->16k
        this.needsResample = this.ratio > 1.001;
        this.resampleIdx = 0;

        this.pcmBuf = new Float32Array(this.bufSize);
        this.pcmIdx = 0;

        // Pre-allocate output buffer pool (zero-GC)
        this.pool = [];
        this.views = [];
        for (let i = 0; i < 4; i++) {
            const ab = new ArrayBuffer(this.bufSize * 2);
            this.pool[i] = ab;
            this.views[i] = new Int16Array(ab);
        }
        this.poolIdx = 0;

        // Perf tracking
        this.perfCount = 0;
        this.perfTotal = 0;
        this.perfMax = 0;

        this._init();
    }

    async _init() {
        try {
            const wasmBinary = b64ToUint8(DFN3_WASM_B64);
            const weightsData = b64ToUint8(DFN3_WEIGHTS_B64);

            const Module = await createDFN3Module({ wasmBinary });
            this.proc = Module;

            // Copy weights into WASM heap
            const wPtr = Module._malloc(weightsData.length);
            Module.HEAPU8.set(weightsData, wPtr);

            // Initialize
            const ret = Module._dfn3_wasm_create(wPtr, weightsData.length);
            if (ret !== 0) throw new Error('dfn3_wasm_create failed');

            this.inputPtr = Module._dfn3_wasm_get_input_ptr();
            this.outputPtr = Module._dfn3_wasm_get_output_ptr();

            // Free weights from heap (already copied into state)
            Module._free(wPtr);

            // Runtime parameters
            Module._dfn3_wasm_set_atten_lim(100);          // no attenuation limit
            Module._dfn3_wasm_set_post_filter_beta(0);     // post-filter disabled
            Module._dfn3_wasm_set_min_db_thresh(-10);
            Module._dfn3_wasm_set_max_db_erb_thresh(30);
            Module._dfn3_wasm_set_max_db_df_thresh(20);

            this.ready = true;
            this.port.postMessage('ready');
            this.port.postMessage({ type: 'init', sampleRate: 48000 });
        } catch (e) {
            this.port.postMessage({ type: 'error', message: e.message || String(e) });
        }
    }

    process(inputs, outputs) {
        if (!this.ready || !inputs[0] || !inputs[0][0]) return true;

        const input = inputs[0][0]; // mono channel, 128 samples

        // Accumulate into DFN3_HOP-sized frames
        let pos = 0;
        while (pos < input.length) {
            const remaining = DFN3_HOP - this.accumPos;
            const toCopy = Math.min(remaining, input.length - pos);
            this.accumBuf.set(input.subarray(pos, pos + toCopy), this.accumPos);
            this.accumPos += toCopy;
            pos += toCopy;

            if (this.accumPos >= DFN3_HOP) {
                this._processFrame();
                this.accumPos = 0;
            }
        }

        return true;
    }

    _processFrame() {
        const M = this.proc;
        const t0 = performance.now();

        // Copy input to WASM
        M.HEAPF32.set(this.accumBuf, this.inputPtr / 4);

        // Process (48kHz in -> 48kHz out)
        M._dfn3_wasm_process();

        // Read 480 enhanced samples @ 48kHz, resample to 16kHz in JS
        const outOffset = this.outputPtr / 4;
        if (this.needsResample) {
            this._resample(M.HEAPF32, outOffset, DFN3_HOP);
        } else {
            this._copy(M.HEAPF32, outOffset, DFN3_HOP);
        }

        // Perf tracking
        const dt = performance.now() - t0;
        this.perfTotal += dt;
        if (dt > this.perfMax) this.perfMax = dt;
        this.perfCount++;
        // Track input/output levels + lsnr
        let inMax = 0, outMax = 0;
        const inOff = this.inputPtr / 4;
        for (let i = 0; i < DFN3_HOP; i++) {
            const ai = Math.abs(M.HEAPF32[inOff + i]);
            const ao = Math.abs(M.HEAPF32[outOffset + i]);
            if (ai > inMax) inMax = ai;
            if (ao > outMax) outMax = ao;
        }
        this.inLevelMax = Math.max(this.inLevelMax || 0, inMax);
        this.outLevelMax = Math.max(this.outLevelMax || 0, outMax);
        this.outZeroCount = (this.outZeroCount || 0) + (outMax < 1e-6 ? 1 : 0);
        const lsnr = M._dfn3_wasm_get_lsnr();
        this.lsnrMin = Math.min(this.lsnrMin ?? 999, lsnr);
        this.lsnrMax = Math.max(this.lsnrMax ?? -999, lsnr);

        if (this.perfCount >= 100) {
            const avg = this.perfTotal / this.perfCount;
            const audioDur = (DFN3_HOP / 48000) * 1000; // 10ms per frame
            this.port.postMessage({
                type: 'perf',
                avg: avg.toFixed(2),
                max: this.perfMax.toFixed(2),
                rtf: (this.perfTotal / (this.perfCount * audioDur)).toFixed(3),
                count: this.perfCount,
                inMax: this.inLevelMax.toFixed(4),
                outMax: this.outLevelMax.toFixed(4),
                zeroFrames: this.outZeroCount,
                lsnrMin: this.lsnrMin.toFixed(1),
                lsnrMax: this.lsnrMax.toFixed(1),
            });
            this.perfCount = 0;
            this.perfTotal = 0;
            this.perfMax = 0;
            this.inLevelMax = 0;
            this.outLevelMax = 0;
            this.outZeroCount = 0;
            this.lsnrMin = 999;
            this.lsnrMax = -999;
        }
    }

    // Linear interpolation resample (matches rnnoise worklet pattern)
    _resample(src, off, len) {
        const buf = this.pcmBuf, size = this.bufSize, ratio = this.ratio;
        let idx = this.pcmIdx, resIdx = this.resampleIdx;
        const last = len - 1;
        while (resIdx < len) {
            const i = resIdx | 0;
            const s0 = src[off + i];
            buf[idx++] = i < last ? s0 + (src[off + i + 1] - s0) * (resIdx - i) : s0;
            resIdx += ratio;
            if (idx >= size) { this._send(); idx = 0; }
        }
        this.pcmIdx = idx;
        this.resampleIdx = resIdx - len;
    }

    _copy(src, off, len) {
        const buf = this.pcmBuf, size = this.bufSize;
        let idx = this.pcmIdx;
        for (let i = 0; i < len; i++) {
            buf[idx++] = src[off + i];
            if (idx >= size) { this._send(); idx = 0; }
        }
        this.pcmIdx = idx;
    }

    _send() {
        const ab = this.pool[this.poolIdx & 3];
        this.poolIdx++;
        const view = new Int16Array(ab, 0, this.bufSize);
        const buf = this.pcmBuf;
        for (let i = 0; i < this.bufSize; i++) {
            let s = buf[i];
            s = s > 1.0 ? 1.0 : (s < -1.0 ? -1.0 : s);
            view[i] = (s * INT16_SCALE) | 0;
        }
        this.port.postMessage({ type: 'pcm', data: ab }, [ab]);
        // Re-create the transferred buffer
        this.pool[(this.poolIdx - 1) & 3] = new ArrayBuffer(this.bufSize * 2);
    }
}

registerProcessor('DFN3Processor', DFN3Worklet);
WORKLET_PROCESSOR

echo "Built: $WORKLET_OUT"
ls -lh "$WORKLET_OUT"

echo ""
echo "=== Build complete ==="
